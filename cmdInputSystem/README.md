*📒 NOTE*

- 搓招机制：（可用从后往前或从前往后匹配）

CommandInput 从后往前————技能释放的时间节点

`buffer`维护一个定长的按键输入队列。当有新的按键输入时，遍历技能表，技能和`buffer`都从后往前比较，若不相同直接判定为匹配失败；若相同还需比较按键间隔是否满足要求，满足时，作为后备释放技能。遍历过程，每有新的匹配成功技能同后备技能比较权重，权重高者替换为新的后备技能。遍历结束后，还需比较后备技能的CD是否符合要求，所有条件均满足时，释放（因为从后往前匹配，成功即代表单个完整技能所有键位都正确）。

CommandDebugger 从前往后————通常的顺序思维

用一个状态对象`States`维护每个技能的情况，记录每个技能即将匹配的键位索引以及上次键位匹配成功时的时间戳。有新的按键输入时，遍历整个技能表，比较每个技能的待匹配键位`expected`同输入按键是否相等，相等时，推进待匹配索引，更新时间戳；不同，则重置技能状态。当单个技能的键位索引推进到末尾时，即作为待释放技能存储。在`update`帧渲染过程中，遍历技能表，实时比较每个技能键位的输入间隔是否超出，超出时技能状态重置；遍历过程中，记录每帧最大匹配索引，若待释放技能键位序列长度大于等于最大索引，则释放。（正常设计正确的技能表，对于包含关系的技能，肯定是谁更长权重更大； 对于一个缓存的待释放技能，若存在技能匹配的键位索引，大于缓存技能的序列长度，则说明可能是权重更高的技能要释放）

- onLoad时节点刚实例化完，属性初始化完，但 还没进行 UI 对齐/布局。

这时候取到的 node.position / worldPosition 不包含 Widget 偏移。

- 点击事件getUILoaction 和 节点worldPosition是匹配的， 会有极小的偏差，应该是不同计算过程中产生的误差

- 移动时必须按下状态时长大于阈值才判定为移动，以防搓招过程中产生的多余碎步

- Prefab 是一个可复用的独立资源，不能保存对场景对象的引用（因为场景和 prefab 的生命周期不同，Prefab 在其他场景里也可能被用到）

- 🐞3.8.6bug 在scene里面拖进一个预制体，然后删掉预制体，再删掉scene里面的预制体那个节点，就会一直报错

解决办法：将.scene里错误的预制体删除或置换为正确的uuid

- 预制体设置worldposition，最好在挂载后再设置，如果先设置再挂载也会受到挂载的父级坐标系发生变化